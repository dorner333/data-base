# Readme

## Тесты на производительность

![Профилирование](https://github.com/ksartamonov/data-base/blob/stat/pictures/testing.png)

Построим график зависимости времени вставки, от количества ключей в базе. Как видно, в приближении время вставки пропорционально количеству ключей.

![График 1](https://github.com/ksartamonov/data-base/blob/stat/pictures/testplot(set).png)

Построим графики зависимости времени поиска и удаления элемента по ключу от количества ключей.

![График 2](https://github.com/ksartamonov/data-base/blob/stat/pictures/testplot(get).png)

В приближении можно сказать, что обе операции выполняются за константное время, независимо 
от количества ключей в таблице.

![График 3](https://github.com/ksartamonov/data-base/blob/stat/pictures/testplot(del).png)

## Анализ различных функций хэширования

В проекте было произведено анализ различных функций хеширования. Некоторые функции были взяты с открытых git-hab`ов, некоторые написаны с помощью алгоритмов для 32 бит.

Критерии, которые важны для некриптографических хеш-функций:

* Выходные значения должны иметь равномерное распределение (uniform distribution). Этот критерий важен для построения хеш-таблиц, чтобы скорость поиска была оптимальна.  

*  Каждый входной бит должен в 50% случаев влиять на каждый выходной бит (avalanche — лавинный критерий). Этот критерий важен для использования хеша в качестве уникального идентификатора 
документа. Также, иногда хеш может иметь равномерное распределение, но проваливать лавинный критерий — в этом случае будут ключи, для которых хеш не будет давать равномерное распределение.

* Между парами бит на выходе не должно быть корреляции. Это рассматривать не будем, т.к. обычно с этим критерием проблемы нет.

* Скорость. Все нижеперечисленные хеши на порядок быстрее, чем криптографические.

В работе были использованы 5 хеш-функций:

1) FNV32
2) CRC32
3) murmur2_32
4) murmur3_32
5) rot1333

Теперь немного подробнее о каждой хеш-функции:

* #### FNV-1a

2003 год. Скорость: 4.5 циклов на байт.
Очень простая функция.
1. Равномерное распределение: плохое
2. Лавинный критерий: плохо. 

* #### CRC32

1975 год, скорость: 1.2–0.13 цикла на байт.
1. Равномерное распределение: плохое распределение нижних бит. Используйте верхние биты для хеш-таблицы, когда можно использовать все протестированные биты — до 16 верхних бит (до 216 слотов хеш-таблицы).
2. Лавинный критерий: очень плохо. Лавинный эффект отсутствует. Сказывается назначение хеша: его выходные биты спроектированы так, чтобы обнаруживать ошибки в канале передачи данных. Также, у CRC есть важное свойство: можно разбить сообщение на части, посчитать хеш для каждой части, потом объединить сообщение, и посчитать хеш всего сообщения из хешей его частей.

* #### MurmurHash 2

2008 год.
Есть проблема с равномерностью распределения некоторых ключей.

* #### MurmurHash 3

2011 год, скорость: 1.87 циклов на байт.
1. Равномерное распределение: хорошее.
2. Лавинный критерий: отлично.

* #### Rot13

Это вариация шифра Цезаря, разработанного в Древнем Риме, быстрая хеш-функция (быстрее SRC32)
1. Равномерное распределение: среднее.
2. Лавинный критерий: плохой.

По теории "лучшей" хеш-функцией должна была оказаться - murmur3, а "наихудшей" - SRC32, в виду плохого распределения и лавинного эфекта. 







## Анализ различных способов разрешения коллизий

## Компиляция и запус:

Чтобы скомпилировать и собрать программу в исполняемый файл, воспользуйтесь командой
```
make
```
в терминале. При этом программа будет скомпилирована без использования оптимизаций и дополнительных ключей. Запуск программы осуществляется при помощи команды
```
./hashdbtest <filename> <hashfunction>
```
Аргумент filename -- имя файла, содержащего базу данных. Если файла нет в текущей дериктории, он будет создан, если же в текущей дериктории уже был файл, содержащий данные, программа откроет его и продолжит работу уже с имеющимися данными.

Аргумент hashfunction -- название функции хэшироваия, которую будет использовать программа. Доступные хэш-функции:
* rot1333
* murmur2_32
* murmur3_32
* CRC32
* FNV32

Заметим так же, что если пользователь не укажет в аргументах командной строки название хэш-функции, сделает ошибку в названии или укажет хэш-функцию, недоступную для использования, то по умолчанию программа будет использовать rot1333.

В программе предусмотрен вариант компиляции с дополнительной оптимизацией -Ofast.
Для этого используйте в терминале команду
```
make Ofast
```
При этом, после завершения и сборки, в терминале появится детальная информация о времени компиляии

Для того, чтобы посмотреть время работы программы, неоюходимо запустить ее с параметром time:
```
time ./hashdbtest <filename> <hashfunction>
```

## Профилирование и тесты

Временами бывает нужно отпрофилировать производительность программы или потребление памяти в программе на C++ и C. В данном проекте так же доступна такая возможность.
Чтобы начать профилирование, воспользуйтесь функцией:
```
make profile
```
Инструкция Makefile выполнить компиляцию со всеми необходимыми ключами, после чего программа будет запущена. При этом в терминале будет отображаться детальная информация о времение работы программы и сообщения callgrind. После завершения работы программы в текущей дериктории будет сформирван файл callgrind.out.*, 

Для просмотра результатов будем использовать программу KCachegrind, который умеет работать с форматом отчетов callgrind, для построения графиков используем gnuplot.

В программе предусмотрено два режима работы: пользовательский режим и режим эксперемента. В режиме эксперемента программа собирает данные о времени работы различных функций и записывает их в файл data.txt для последующего использования. Для того, чтобы включить режим экспереента перейтите в файл hashdbtest.c и раскоментируйте 18 строчку:
```
//#define STAT
```
```
#define STAT
```
После этого заново скомпилируйте программу (см. пункт Компиляция и запуск).

## bush-скрипты

Проект содержит 3 bush-скрипта для автоматизации проведения тестов. Для того, чтобы использовать bush-скрипт, его нужно сделать исполняемым, для этого используем команду
```
chmod +x script.sh
```
После этого файл .sh может быть запущен:
```
./script.sh
```