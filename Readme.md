# Readme

## Тесты на производительность

![Профилирование](https://github.com/ksartamonov/data-base/blob/stat/pictures/testing.png)

Построим график зависимости времени вставки, от количества ключей в базе. Как видно, в приближении время вставки пропорционально количеству ключей.

![График 1](https://github.com/ksartamonov/data-base/blob/stat/pictures/testplot(set).png)

Построим графики зависимости времени поиска и удаления элемента по ключу от количества ключей.

![График 2](https://github.com/ksartamonov/data-base/blob/stat/pictures/testplot(get).png)

В приближении можно сказать, что обе операции выполняются за константное время, независимо 
от количества ключей в таблице.

![График 3](https://github.com/ksartamonov/data-base/blob/stat/pictures/testplot(del).png)

## Анализ различных функций хэширования

## Анализ различных способов разрешения коллизий

## Компиляция и запус:

Чтобы скомпилировать и собрать программу в исполняемый файл, воспользуйтесь командой
```
make
```
в терминале. При этом программа будет скомпилирована без использования оптимизаций и дополнительных ключей. Запуск программы осуществляется при помощи команды
```
./hashdbtest <filename> <hashfunction>
```
Аргумент filename -- имя файла, содержащего базу данных. Если файла нет в текущей дериктории, он будет создан, если же в текущей дериктории уже был файл, содержащий данные, программа откроет его и продолжит работу уже с имеющимися данными.

Аргумент hashfunction -- название функции хэшироваия, которую будет использовать программа. Доступные хэш-функции:
* rot1333
* murmur2_32
* murmur3_32
* CRC32
* FNV32

Заметим так же, что если пользователь не укажет в аргументах командной строки название хэш-функции, сделает ошибку в названии или укажет хэш-функцию, недоступную для использования, то по умолчанию программа будет использовать rot1333.

В программе предусмотрен вариант компиляции с дополнительной оптимизацией -Ofast.
Для этого используйте в терминале команду
```
make Ofast
```
При этом, после завершения и сборки, в терминале появится детальная информация о времени компиляии

Для того, чтобы посмотреть время работы программы, неоюходимо запустить ее с параметром time:
```
time ./hashdbtest <filename> <hashfunction>
```

## Профилирование и тесты

Временами бывает нужно отпрофилировать производительность программы или потребление памяти в программе на C++ и C. В данном проекте так же доступна такая возможность.
Чтобы начать профилирование, воспользуйтесь функцией:
```
make profile
```
Инструкция Makefile выполнить компиляцию со всеми необходимыми ключами, после чего программа будет запущена. При этом в терминале будет отображаться детальная информация о времение работы программы и сообщения callgrind. После завершения работы программы в текущей дериктории будет сформирван файл callgrind.out.*, 

Для просмотра результатов будем использовать программу KCachegrind, который умеет работать с форматом отчетов callgrind, для построения графиков используем gnuplot.

В программе предусмотрено два режима работы: пользовательский режим и режим эксперемента. В режиме эксперемента программа собирает данные о времени работы различных функций и записывает их в файл data.txt для последующего использования. Для того, чтобы включить режим экспереента перейтите в файл hashdbtest.c и раскоментируйте 18 строчку:
```
//#define STAT
```
```
#define STAT
```
После этого заново скомпилируйте программу (см. пункт Компиляция и запуск).

## bush-скрипты

Проект содержит 3 bush-скрипта для автоматизации проведения тестов. Для того, чтобы использовать bush-скрипт, его нужно сделать исполняемым, для этого используем команду
```
chmod +x script.sh
```
После этого файл .sh может быть запущен:
```
./script.sh
```