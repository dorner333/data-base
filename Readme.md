# Персистентная база данных

# Тесты на корректность и производительность

## Тесты на производительность

![Профилирование](https://github.com/ksartamonov/data-base/blob/stat/pictures/testing.png)
Построим график зависимости времени вставки, от количества ключей в базе. Как видно, в приближении время вставки пропорционально количеству ключей.
![График 1](https://github.com/ksartamonov/data-base/blob/stat/pictures/testplot(set).png)
Построим графики зависимости времени поиска и удаления элемента по ключу от количества ключей.
![График 2](https://github.com/ksartamonov/data-base/blob/stat/pictures/testplot(get).png)
В приближении можно сказать, что обе операции выполняются за константное время, независимо от количества ключей в таблице.
![График 3](https://github.com/ksartamonov/data-base/blob/stat/pictures/testplot(del).png)

## Анализ различных функций хэширования
## Анализ различных способов разрешения коллизий

# Компиляция, запуск и профилирование

## Компиляция и запус:

Чтобы скомпилировать и собрать программу в исполняемый файл, воспользуйтесь командой
```
make All
```
в терминале. При этом программа будет скомпилирована без использования оптимизаций и дополнительных ключей. Запуск программы осуществляется при помощи команды
```
./hashdbtest <filename>
```
где filename -- имя файла, содержащего базу данных. Если файла нет в текущей дериктории, он будет создан, если же в текущей дериктории уже был файл, содержащий данные, программа откроет его и продолжит работу уже с имеющимися данными.

Компиляция с ключем -Ofast и отображение времени компиляции:
```
make details
```
Для отображения времени работы программы запуск с ключем time:
```
time ./hashdbtest <filename>
```

## Профилирование и тесты
Запуск с профилированием
```
make details
make profile
```
Для профилироваия и визуализации результатов используем valgrind, callgrind и kcachegrind, для построения графиков используем gnuplot.
